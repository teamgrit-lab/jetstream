{"version":3,"sources":["webpack://StreamMixer/webpack/universalModuleDefinition","webpack://StreamMixer/webpack/bootstrap","webpack://StreamMixer/./src/index.js","webpack://StreamMixer/./src/StreamMixer.Debugger.js","webpack://StreamMixer/./src/AudioMixer/AudioObject.js","webpack://StreamMixer/./src/AudioMixer/AudioMixer.js","webpack://StreamMixer/./src/Utils/BrowserCheck.js","webpack://StreamMixer/./src/VideoMixer/VideoMixer.js","webpack://StreamMixer/./src/VideoMixer/preset/POSITIONS.js","webpack://StreamMixer/./src/VideoMixer/VideoObject.js","webpack://StreamMixer/./src/StreamMixer.js","webpack://StreamMixer/./src/Module.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","console","log","default","StreamMixer_Debugger","_startTime","_videoState","videoMixer","videoElementList","droppedFrames","cTime","performance","now","cDebug","label","params","init","showObjectList","Frames","_lastExecuteTime","_lastFrameDelay","setLastExecuteTime","time","setLastFrameDelay","lastDrawTime","lastDrawTimeVideoObjects","showObjectDrawTimes","DroppedFrames","increase","show","div","AudioObject","[object Object]","id","source","sourceType","context","destination","mediaType","muted","_id","_source","_sourceType","_audioCtx","_destination","_mediaType","_muted","_sourceNode","createMediaStreamSource","createMediaElementSource","_gainNode","createGain","gain","filter","createBiquadFilter","geometricMean","Math","sqrt","frequency","Q","connect","disconnect","setValueAtTime","currentTime","AudioMixer","AudioContext","window","webkitAudioContext","audioCtx","createMediaStreamDestination","_isEnable","audioObjectList","addNoiseOscillator","oscillator","createOscillator","type","start","masterNode","aObj","push","idx","findIndex","val","splice","stream","getTracks","mute","setVolume","BrowserCheck","agent","navigator","userAgent","toLowerCase","indexOf","SCREEN","width","height","FRAMES_PER_SECOND","FRAME_MIN_TIME","INTERVAL","lastFrameTime","SIZE","MIN_WIDTH","MIN_HEIGHT","GUIDE","POINT_SIZE","LINE_WIDTH","LINE_COLOR","Z_INDEX_BUTTON_WIDTH","Z_INDEX_BUTTON_HEIGHT","Z_INDEX_BUTTON_COLOR","Z_INDEX_BUTTON_COLOR_UP","Z_INDEX_BUTTON_COLOR_DOWN","Z_INDEX_TEXT_FONT","Z_INDEX_TEXT_FONT_SIZE","Z_INDEX_TEXT_WIDTH","Z_INDEX_TEXT_HEIGHT","ARROW_WIDTH","ARROW_HEIGHT","ARROW_COLOR","MOUSE_BUTTON","NONE","CLICKED","SETTINGS","Z_INDEX_MIN","Z_INDEX_MAX","VideoMixer_VideoMixer","elementID","videoObjectList","videoObjectListAsc","mouseButtonState","initCanvas","vRatio","uiCanvas","offsetWidth","hRatio","offsetHeight","delta","then","Date","bindEventHandler","canvasElementID","document","getElementById","uiCanvasCtx","getContext","desynchronized","alpha","frontCanvas","createElement","frontCanvasCtx","mixedStream","captureStream","widthRatio","heightRatio","forEach","vObj","setPosition","top","left","setVisible","sortVideoObjectList","ascIdx","detachEventObject","requestAnimationFrame","drawCalcDeltaTime","clearRect","fillStyle","fillRect","drawSource","getDrawSource","src","videoWidth","videoHeight","drawImage","pointPositions","drawPoints","mouseOverObject","isFullscreen","drawOutline","drawTriangle","drawZIndexButton","getVideoTracks","requestFrame","destObject","ctx","strokeStyle","lineWidth","strokeRect","parseInt","beginPath","x","y","moveTo","lineTo","closePath","fill","drawTopLeft","drawBottomRight","objTop","objRight","drawUpButton","color","drawDownButton","clickPosition","drawButtonBackground","drawUpArrow","drawDownArrow","positions","position","arc","PI","captureFrame","canvas","sort","a","b","zIndex","createdAt","length","ondblclick","e","clickObj","findClickObject","hasSavedPosition","restorePosition","savePosition","ratio","fullScreen","aspectRatio","calcWidth","calcHeight","onmousedown","button","clickObject","startPos","offsetX","offsetY","startObjectPos","bottom","right","onmouseover","onmouseout","onmousemove","detectMouseOut","style","cursor","moveX","moveY","moveX_inCanvas","calcUItoCanvasX","moveY_inCanvas","calcUItoCanvasY","resizeWidth","resizeHeight","onmouseup","onclick","objList","mouseX","mouseY","find","objLeft","objBottom","map","videoObj","lastDrawExecuteTime","toString","POSITIONS_SCREEN","MARGIN","TOP","LEFT","RIGHT","BOTTOM","POSITIONS_SIZE","SMALL","WIDTH","HEIGHT","getHorizontalRight","getHorizontalCenter","getVerticalBottom","objWidth","objHeight","VideoObject_VideoObject","props","autoSize","transparent","onended","visible","_transparent","_visible","_top","_left","_bottom","_right","_width","_height","_zIndex","_fullScreen","_createdAt","wScale","max","_savedPosition","_oldTop","_oldLeft","_oldBottom","_oldRight","_oldWidth","_oldHeight","_oldZIndex","_oldFullScreen","oldRight","values","undefined","outLine","onOff","_outline","_drawExecuteTime","StreamMixer","_videoElementList","_videoMixer","_audioMixer","_outputStream","_initSuccess","initOutputStream","async","MediaStream","track","addTrack","getAudioTracks","findVideoItem","objID","k","initSuccess","getIDs","getVideoElement","videoEl","addMedia","video","audio","Promise","resolve","reject","random","substr","generateID","autoplay","load","startTime","crossOrigin","srcObject","play","addVideoObject","getDestination","addAudioObject","catch","err","removeMedia","removeVideoObject","removeAudioObject","changeStream","item","getStream","setResolution","resolution","pause","getCurrentTime","setCurrentTime","getVideoObject","setPointPositions","clearPoints","Debug","__webpack_exports__"],"mappings":"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","file":"stream-mixer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StreamMixer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StreamMixer\"] = factory();\n\telse\n\t\troot[\"StreamMixer\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","console.log(\"%cStreamMixer 1.7.56\", 'font-weight: 700;')\nmodule.exports = require('./Module').default;","export default (function() {\n    let _startTime = null;\n    let _videoState = {\n        videoMixer: null,\n        videoElementList: 0,\n        droppedFrames: 0,\n    }\n\n    function cTime() {\n        console.log((`%c[START TIME]%c : ${_startTime}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n        console.log((`%c[CURRENT TIME]%c : ${performance.now()}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n    }\n\n    function cDebug(label, params) {\n        console.log(`%c[DEBUG]%c(${label}) : ${params}`,\n                    // 'font-weight: 700;',\n                    'font-weight: 700; color: white; background: green;',\n                    'font-weight: 400; background: none');\n    }\n\n    function init(videoElementList, videoMixer) {\n        _startTime = performance.now();\n        _videoState.videoMixer = videoMixer;\n        _videoState.videoElementList = videoElementList\n    }\n\n    function showObjectList() {\n        cDebug(\"ObjectList\", _videoState.videoElementList)\n    }\n\n    let Frames = (function(){\n        let _lastExecuteTime = 0;\n        let _lastFrameDelay = 0;\n        function setLastExecuteTime(time) {\n            _lastExecuteTime = time;\n        }\n        function setLastFrameDelay(time){\n            _lastFrameDelay = time;\n        }\n        function lastDrawTime() {\n            cTime();\n            cDebug(\"LastExecuteTime\", _lastExecuteTime);\n            cDebug(\"LastFrameDelay\", _lastFrameDelay);\n            cDebug(\"Total\", _lastExecuteTime + _lastFrameDelay);\n        }\n\n        function lastDrawTimeVideoObjects() {\n            cTime();\n            cDebug(\"ObjectsLastExecuteTime\", _videoState.videoMixer.showObjectDrawTimes() )\n        }\n\n        return { setLastExecuteTime, setLastFrameDelay, lastDrawTime, lastDrawTimeVideoObjects }\n    })()\n\n    let DroppedFrames = (function() {\n        function increase() {\n            _videoState.droppedFrames = _videoState.droppedFrames + 1;\n        }\n        function show() {\n            cTime();\n            cDebug(\"DroppedFrames\", _videoState.droppedFrames);\n            const div = (performance.now() - _startTime) / 1000\n            cDebug(\"DroppedFrames/s\", _videoState.droppedFrames / div);\n        }\n\n        return { increase, show }\n    })()\n\n    return {\n        init,\n        showObjectList,\n        Frames,\n        DroppedFrames\n    }\n})()","export const convertAudioStream = src => {\n    const stream = new MediaStream();\n    \n    if (src instanceof MediaStream) {\n        src.getAudioTracks().forEach(track => stream.addTrack(track));\n    }\n    else if (src instanceof MediaStreamTrack) {\n        stream.addTrack(src);\n    }\n    // else throw new Error();\n\n    return stream;\n};\n\nexport default class AudioObject {\n    constructor({\n        id,\n        source = null,\n        sourceType = \"stream\",\n        context,\n        destination,\n        mediaType,\n        muted,\n    }) {\n        this._id = id;\n        this._source = source;\n        this._sourceType = sourceType;\n        // this._source = convertAudioStream(source);\n        this._audioCtx = context;\n        this._destination = destination;\n\n        this._mediaType = mediaType;\n        this._muted = muted;\n\n        // this._filteredNode = this._audioCtx.createGain();\n        // this._filteredNode.gain.value = 1.0;\n        if(this._sourceType === \"stream\") {\n            this._sourceNode = this._audioCtx.createMediaStreamSource(this._source);\n        } else {\n            this._sourceNode = this._audioCtx.createMediaElementSource(this._source);\n        }\n\n        this._gainNode = this._audioCtx.createGain();\n\n        if (mediaType === \"mycam\") {\n            this._gainNode.gain.value = 0.5;\n            // voice bandpass filter\n            const filter = this._audioCtx.createBiquadFilter()\n            var geometricMean = Math.sqrt(300 * 3400);\n            filter.frequency.value = geometricMean;\n            filter.Q.value = geometricMean / (300 - 3400);\n\n            // if mic node is source then -> filter -> gain -> dest\n            this._sourceNode.connect(filter);\n            filter.connect(this._gainNode);\n        } else {\n            this._gainNode.gain.value = 1.0;\n            // if mic node is not source then -> gain -> dest\n            this._sourceNode.connect(this._gainNode);\n        }\n\n        this._gainNode.connect(this._destination);\n\n\n        // this._audio.play();\n        // console.log(this._destination)\n\n        // this._gainNode = this._audioCtx.createGain();\n        // this._gainNode.gain.value = 1.0;\n\n        // this._sourceNode.connect(this._gainNode);\n// console.log(\"audio type\", type)\n//         if (type === \"mic\") {\n//             const lowpassFilterNode = this._audioCtx.createBiquadFilter();\n//             lowpassFilterNode.type = 'lowpass';\n//             lowpassFilterNode.frequency.setValueAtTime(100, this._audioCtx.currentTime);\n\n//             const highpassFilterNode = this._audioCtx.createBiquadFilter();\n//             highpassFilterNode.type = 'highpass';\n//             highpassFilterNode.frequency.setValueAtTime(1500, this._audioCtx.currentTime);\n\n//             this._gainNode.connect(lowpassFilterNode);\n//             lowpassFilterNode.connect(highpassFilterNode);\n//             highpassFilterNode.connect(this._filteredNode);\n//         } else {\n//             this._gainNode.connect(this._filteredNode)\n//         }\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    disconnect() {\n        this._gainNode.disconnect();\n        this._sourceNode.disconnect();\n    }\n\n    mute(value) {\n        if(value) {\n            this._gainNode.gain.setValueAtTime(0, this._audioCtx.currentTime);\n        } else {\n            // this._sourceNode.connect(this._gainNode);\n            // this._gainNode.connect(this._destination);\n\n            // if (this._mediaType === \"mic\") {\n            //     this._gainNode.gain.setValueAtTime(0.5, this._audioCtx.currentTime);\n            // } else {\n            //     this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n            // }\n            this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n        }\n    }\n\n    setVolume(value) {\n        this._gainNode.gain.setValueAtTime(value, this._audioCtx.currentTime);\n    }\n\n}","import AudioObject, { convertAudioStream } from \"./AudioObject\";\n\n\nconst setVolume = ({ node, volume }) => {\n    const _volume = parseInt(volume, 10) / 100;\n    if (_volume < 0 || _volume > 1) throw new Error('volume scope exceed');\n    if (!node) throw new Error('node is null');\n\n    // eslint-disable-next-line no-param-reassign\n    node.gain.value = _volume;\n};\n\nconst getVolume = node => {\n    return node.gain.value;\n};\n\nexport default class AudioMixer {\n    constructor() {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        \n        this.audioCtx = new AudioContext();\n        this.destination = this.audioCtx.createMediaStreamDestination();\n        this._isEnable = true;\n        this.audioObjectList = [];\n\n        this.addNoiseOscillator();\n    }\n\n    addNoiseOscillator() {\n        const oscillator = this.audioCtx.createOscillator();\n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(24000, this.audioCtx.currentTime); // value in hertz\n        oscillator.connect(this.destination);\n        oscillator.start();\n    }\n\n    getContext() {\n        return this.audioCtx;\n    }\n\n    getDestination() {\n        return this.destination;\n    }\n\n    getMasterNode() {\n        return this.masterNode;\n    }\n    \n\n    addAudioObject(aObj) {\n        this.audioObjectList.push(\n            aObj\n        )\n    }\n\n    removeAudioObject(id) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        if(idx === -1) return;\n        const aObj = this.audioObjectList[idx];\n        aObj.disconnect();\n        this.audioObjectList.splice(idx, 1)\n    }\n\n    getAudioTracks() {\n        return this.destination.stream.getTracks();\n    }\n \n    mute(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.mute(value);\n    }\n\n    setVolume(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.setVolume(value)\n    }\n}\n","export default function () {\n    var agent = navigator.userAgent.toLowerCase();\n    if (agent.indexOf(\"msie\") != -1) {    //익스플로러인지 체크\n        return \"msie\";\n    }\n    if (agent.indexOf(\"chrome\") != -1) {\n        return \"chrome\";\n    }\n    if (agent.indexOf(\"safari\") != -1) {\n        return \"safari\";\n    }\n    if (agent.indexOf(\"firefox\") != -1) {\n        return \"firefox\";\n    }\n    return \"other\"\n    // 출처: https://kunoo.tistory.com/entry/javascript-브라우저-체크-browser-check [Kunoo]\n}","import Debugger from '../StreamMixer.Debugger';\n// import VideoObject from './VideoObject';\n\n// import { WORKER_MESSAGE_TYPE } from './workers/VideoMixerWorker';\nimport Browser from '../Utils/BrowserCheck';\n\nexport const EXT_WORKER_MESSAGE_TYPE = {\n    PUT_OFFSCREEN: \"PUT_OFFSCREEN\"\n}\n\nlet SCREEN = {\n    width: 1280,\n    height: 720,\n    // width: 640,\n    // height: 360,\n    // width: 320,\n    // height: 180\n}\n\nconst FRAMES_PER_SECOND = 60;\n// requesetAnimFrame용\nconst FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;\n// same\nconst INTERVAL = 1000 / FRAMES_PER_SECOND;\nconst MAX_FRAME_TIME = 1000 / FRAMES_PER_SECOND;\nconst MIN_FRAME_TIME = 20;\n// 16.666666666666667 * 2 - 16.666666666666667 * 0.5 = 25\n// const _drawInterval = parseInt(1000 / FRAMES_PER_SECOND);\nlet lastDrawTime = 0;\nlet lastFrameTime = 0;\n\n// 객체 grid 관련\nconst SIZE = {\n    MIN_WIDTH: 370,\n    MIN_HEIGHT: 208\n}\n\nconst GUIDE = {\n    POINT_SIZE: 40,\n    LINE_WIDTH: 4,\n    LINE_COLOR: \"rgba(0,184,152,1)\", // \"#F81894\"; hotpink\n    Z_INDEX_BUTTON_WIDTH: 80,\n    Z_INDEX_BUTTON_HEIGHT: 60,\n    Z_INDEX_BUTTON_COLOR: \"rgba(0,184,152,.75)\",\n    Z_INDEX_BUTTON_COLOR_UP: \"rgba(0,184,152,.85)\",\n    Z_INDEX_BUTTON_COLOR_DOWN: \"rgba(0,184,152,.5)\",\n    Z_INDEX_TEXT_FONT: \"48px Arial\",\n    Z_INDEX_TEXT_FONT_SIZE: 48,\n    Z_INDEX_TEXT_WIDTH: 80,\n    Z_INDEX_TEXT_HEIGHT: 80,\n    ARROW_WIDTH: 28,\n    ARROW_HEIGHT: 28,\n    ARROW_COLOR: \"#222222\"\n}\n\n// 마우스 버튼 custom constraint\n// (event.button의 상태가 non-click, click이 둘다 0이기 떄문에 non-click = -1, click = 0으로 지정)\nconst MOUSE_BUTTON = {\n    NONE: -1,\n    CLICKED: 0\n}\n\nconst SETTINGS = {\n    Z_INDEX_MIN: 1,\n    Z_INDEX_MAX: 9\n}\nexport default class VideoMixer {\n    constructor({elementID, width, height}) {\n        this.videoObjectList = [];\n        this.videoObjectListAsc = [];\n\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n\n        SCREEN.width = width;\n        SCREEN.height = height;\n\n        this.initCanvas(elementID);\n\n        // vertical , horizontal 캔버스가 화면에 1:1로 보여주는게 아니기 떄문에 마우스 좌표에 ratio값을 곱해줘야함\n        this.vRatio = SCREEN.width / this.uiCanvas.offsetWidth;\n        this.hRatio = SCREEN.height / this.uiCanvas.offsetHeight;\n\n        this.delta = 0;\n        this.now = 0;\n        this.then = Date.now();\n        this.bindEventHandler();\n\n        console.log('VideoMixer Init');\n        console.log('Browser : ', Browser());\n        console.log(`RESOLUTION : ${SCREEN.width} x ${SCREEN.height}`);\n        console.log(`FPS : ${FRAMES_PER_SECOND}`);\n    }\n\n    initCanvas(canvasElementID) {\n        // init uiCanvas\n        this.uiCanvas = document.getElementById(canvasElementID);\n        this.uiCanvasCtx = this.uiCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n        this.uiCanvas.width = SCREEN.width;\n        this.uiCanvas.height = SCREEN.height;\n\n        // init frontCanvas\n        this.frontCanvas = document.createElement('canvas');\n        this.frontCanvas.width = SCREEN.width;\n        this.frontCanvas.height = SCREEN.height;\n        this.frontCanvasCtx = this.frontCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n\n        // issue: captureStream parameter로 프레임을 지정시 오히려 캡쳐가 끊기는 현상이 있음\n        // 일단은 parameter를 비우고 진행 (2019.11.4 기만)\n        // firefox는 request\n        if(Browser() === \"chrome\" || Browser() === \"safari\") {\n            this.mixedStream = this.frontCanvas.captureStream(0);\n        } else { \n            this.mixedStream = this.frontCanvas.captureStream();\n        }\n    }\n\n    setResolution({width, height}) {\n        const widthRatio = SCREEN.width / width;\n        const heightRatio = SCREEN.height / height;\n\n        SCREEN.width = width;\n        SCREEN.height = height;\n\n        this.uiCanvas.width = SCREEN.width;\n        this.uiCanvas.height = SCREEN.height;\n\n        this.frontCanvas.width = SCREEN.width;\n        this.frontCanvas.height = SCREEN.height;\n\n        this.vRatio = SCREEN.width / this.uiCanvas.offsetWidth;\n        this.hRatio = SCREEN.height / this.uiCanvas.offsetHeight;\n        // resize video objects\n        this.videoObjectList.forEach( vObj => {\n            vObj.setPosition({\n                top: vObj.top / heightRatio,\n                left: vObj.left / widthRatio,\n                width: vObj.width / widthRatio,\n                height: vObj.height / heightRatio\n            })\n            console.log(vObj)\n        })\n    }\n\n    // attachMainWorker(workerInstance) {\n    //     this._mainWorker = workerInstance;\n    //     this._mainWorker.postMessage({\n    //         type: WORKER_MESSAGE_TYPE.ATTACH_CANVAS,\n    //         maincanvas: this.transferControl\n    //     }, [this.transferControl])\n\n    //     // this._mainWorker.onmessage = function(e) {\n    //     //     switch(e.data.type) {\n    //     //         case WORKER_MESSAGE_TYPE.PUT_OFFSCREEN:\n    //     //             const offscreenCtx = e.data.offscreen.getContext(\"2d\");\n        \n    //     //             const imageData = offscreenCtx.getImageData(0,0,offscreenCtx.width, offscreenCtx.height);\n        \n    //     //             this.canvasCtx.putImageData(imageData, 0, 0)\n    //     //             break;\n    //     //     }\n    //     // }\n    // }\n\n    setVisible(id, value) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        vObj.setVisible(value)\n    }\n\n    getVideoObject(id) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        return vObj;\n    }\n\n    addVideoObject(vObj) {\n        this.videoObjectList.push(vObj);\n        this.sortVideoObjectList();\n        // console.log(videoObject)\n        // clearTimeout(this._drawTimeoutHandler);\n        \n        // this.drawWithWorker(this.videoObjectList);\n\n        // const workerObject = {\n            // id: videoObject.id,\n            // top: videoObject.top,\n            // left: videoObject.left,\n            // width: videoObject.width,\n            // height: videoObject.height,\n            // zIndex: videoObject.zIndex,\n            // fillMode: videoObject.fillMode,\n            // transparent: videoObject.transparent,\n            // offscreen: videoObject.getOffscreenCanvas()\n        // }\n        // console.log(workerObject)\n        // this._mainWorker.postMessage({\n        //     TYPE: WORKER_MESSAGE_TYPE.ADD_OBJECT,\n        //     object: workerObject,\n        // });\n    }\n\n    removeVideoObject(id) {\n        const idx = this.videoObjectList.findIndex( val => val.id === id );\n        this.videoObjectList.splice(idx, 1);\n        const ascIdx = this.videoObjectListAsc.findIndex( val => val.id === id);\n        this.videoObjectListAsc.splice(ascIdx, 1);\n        this.detachEventObject();\n    }\n\n    // draw(time) {\n    //     if(time - lastDrawTime < MAX_FRAME_TIME) {\n    //         // this.draw(performance.now());\n    //         window.requestAnimationFrame(this.draw.bind(this));\n    //         return;\n    //     }\n    //     lastDrawTime = time;\n\n    //     // clear & fill black background\n    //     // perfomance test clearRect() vs fillRect()\n    //     // https://stackoverflow.com/a/30830253\n    //     // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n    //     this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n    //     this.bufferCanvasCtx.fillStyle = \"black\";\n    //     this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n    //     // draw video objects (order zIndex)\n    //     this.videoObjectList.map( vObj => {\n    //         const drawSource = vObj.getDrawSource();\n    //         if (!drawSource) return;\n    //         const { src } = drawSource;\n \n    //         // drawImage의 방법 세가지중 이방법은 최적화의 좋지 않아 구조 변경함.\n    //         // drawImage의 첫번째 메소드(3파라미터)를 쓰는게 최적화 방법에 제일 좋다고함 (2019-12-12 기만)\n    //         // this.canvasCtx.drawImage(\n    //         //     src,\n    //         //     0,\n    //         //     0,\n    //         //     srcWidth,\n    //         //     srcHeight,\n    //         //     vObj.drawLeft,\n    //         //     vObj.drawTop,\n    //         //     vObj.drawWidth,\n    //         //     vObj.drawHeight\n    //         // )\n    //         this.bufferCanvasCtx.drawImage(\n    //             src,\n    //             vObj.left,\n    //             vObj.top\n    //         )\n    //     })\n\n    //     // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n    //     if (typeof (OffscreenCanvas))\n    //         this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n    //     // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n    //     this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n    //     if (this.mouseOverObject) {\n    //         if (!this.mouseOverObject.isFullscreen()) {\n    //             this.drawOutline();\n    //             this.drawTriangle();\n    //         }\n    //         this.drawZIndexButton();\n    //     }\n    //     // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n    //     // this.draw(performance.now())\n    //     // setTimeout(this.draw.bind(this), 10, performance.now())\n    //     window.requestAnimationFrame(this.draw.bind(this));\n    // }\n\n    drawCalcDeltaTime() {\n        window.requestAnimationFrame(this.drawCalcDeltaTime.bind(this))\n        this.now = Date.now();\n        this.delta = this.now - this.then;\n\n        if(this.delta > INTERVAL) {\n            this.then = this.now - (this.delta % INTERVAL);\n\n            // clear & fill black background\n            // perfomance test clearRect() vs fillRect()\n            // https://stackoverflow.com/a/30830253\n            // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n            this.frontCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n            this.frontCanvasCtx.fillStyle = \"black\";\n            this.frontCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n            // draw video objects (ordered by zIndex asc)\n            this.videoObjectList.forEach( vObj => {\n                const drawSource = vObj.getDrawSource();\n                if (!drawSource) return;\n                const { src, videoWidth, videoHeight } = drawSource;\n                this.frontCanvasCtx.drawImage(\n                    src, 0, 0, videoWidth, videoHeight,\n                    vObj.left, vObj.top, vObj.width, vObj.height\n                )\n            })\n\n            if (this.pointPositions) {\n                this.drawPoints();\n            }\n    \n            // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n            this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n            if (this.mouseOverObject) {\n                if (!this.mouseOverObject.isFullscreen()) {\n                    this.drawOutline();\n                    this.drawTriangle();\n                }\n                this.drawZIndexButton();\n            }\n\n            // firefox not valid requestFrame\n            if(this.mixedStream.getVideoTracks()[0].requestFrame)\n                this.mixedStream.getVideoTracks()[0].requestFrame();\n        }\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n        // this.draw(performance.now())\n        // setTimeout(this.draw.bind(this), 10, performance.now())\n    }\n\n    // drawWithFps() {\n    //     this.startTime = Date.now();\n\n    //     // clear & fill black background\n    //     this.frontCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n    //     this.frontCanvasCtx.fillStyle = \"black\";\n    //     this.frontCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n    //     // draw video objects (order zIndex)\n    //     this.videoObjectList.map( vObj => {\n    //         const drawSource = vObj.getDrawSource();\n    //         if (!drawSource) return;\n    //         const { src, videoWidth, videoHeight } = drawSource;\n\n    //         this.frontCanvasCtx.drawImage(\n    //             src, 0, 0, videoWidth, videoHeight,\n    //             vObj.left, vObj.top, vObj.width, vObj.height\n    //         )\n    //     })\n\n    //     // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n    //     this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n    //     if (this.mouseOverObject) {\n    //         if (!this.mouseOverObject.isFullscreen()) {\n    //             this.drawOutline();\n    //             this.drawTriangle();\n    //         }\n    //         this.drawZIndexButton();\n    //     }\n\n    //     this.mixedStream.getVideoTracks()[0].requestFrame();\n        \n    //     this.executeTime = Date.now() - this.startTime;\n    //     this.nextFrameDelay = MAX_FRAME_TIME - this.executeTime;\n    //     if(this.nextFrameDelay <= MIN_FRAME_TIME) {\n    //         this.nextFrameDelay = MIN_FRAME_TIME;\n    //         Debugger.DroppedFrames.increase();\n    //     }\n    //     Debugger.Frames.setLastExecuteTime(this.executeTime);\n    //     Debugger.Frames.setLastFrameDelay(this.nextFrameDelay);\n        \n\n    //     // console.log(this.nextFrameDelay)\n    //     // console.log(\"예상:\", performance.now() + this.nextFrameDelay)\n    //     setTimeout(\n    //         this.drawWithFps.bind(this),\n    //         this.nextFrameDelay\n    //     )\n    //     // window.requestAnimationFrame(this.drawWithFps.bind(this))\n    // }\n\n    drawOutline() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        ctx.strokeStyle = GUIDE.LINE_COLOR;\n        ctx.lineWidth = GUIDE.LINE_WIDTH;\n        ctx.strokeRect(\n            destObject.left + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.top + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.width - parseInt(GUIDE.LINE_WIDTH + 1),\n            destObject.height - parseInt(GUIDE.LINE_WIDTH + 1)\n        );\n    }\n\n    drawTriangle() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n\n        const drawTopLeft = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left;\n            let y = destObject.top;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + GUIDE.POINT_SIZE;\n            y = destObject.top;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left;\n            y = destObject.top + GUIDE.POINT_SIZE;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();            \n        }\n        const drawBottomRight = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left + destObject.width;\n            let y = destObject.top + destObject.height - GUIDE.POINT_SIZE;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + destObject.width;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left + destObject.width - GUIDE.POINT_SIZE;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n    \n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();\n        }\n        drawTopLeft();\n        drawBottomRight();\n    }\n\n    drawZIndexButton() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        let objTop = destObject.top + GUIDE.LINE_WIDTH;\n        let objRight = destObject.left + destObject.width - GUIDE.LINE_WIDTH;\n        if(destObject.isFullscreen()) {\n            objRight = SCREEN.width;\n        }\n        const drawButtonBackground = () => {\n            const drawUpButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n\n            const drawDownButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n            \n            switch(this.clickPosition) {\n                case \"up-arrow\":\n                    if(this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                case \"down-arrow\":\n                    if (this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                default:\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n            }\n\n        }\n\n        const drawUpArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop + ((GUIDE.Z_INDEX_BUTTON_HEIGHT - GUIDE.ARROW_HEIGHT) / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y + GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawDownArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop +\n                GUIDE.Z_INDEX_BUTTON_HEIGHT +\n                // GUIDE.Z_INDEX_TEXT_HEIGHT +\n                (GUIDE.Z_INDEX_BUTTON_HEIGHT / 2 + GUIDE.ARROW_HEIGHT / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y - GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawZIndexText = () => {\n            // background\n            ctx.fillStyle = GUIDE.Z_INDEX_BUTTON_COLOR;\n            ctx.fillRect(\n                objRight - GUIDE.Z_INDEX_TEXT_WIDTH,\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                GUIDE.Z_INDEX_TEXT_WIDTH,\n                GUIDE.Z_INDEX_TEXT_HEIGHT,\n            );\n            // text\n            ctx.font = GUIDE.Z_INDEX_TEXT_FONT;\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fillText(\n                destObject.zIndex,\n                objRight - (GUIDE.Z_INDEX_TEXT_WIDTH / 2),\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT + (GUIDE.Z_INDEX_TEXT_HEIGHT / 2)\n            )\n        }\n\n        drawButtonBackground();\n        drawUpArrow();\n        drawDownArrow();\n        // drawZIndexText();\n    }\n\n    setPointPositions(positions) {\n        this.pointPositions = positions;\n    }\n\n    drawPoints() {\n        const POINT_RADIUS = 5;\n        const POINT_COLOR = 'aqua';\n        const ctx = this.frontCanvasCtx;\n        this.pointPositions.forEach(position => {\n            const {x, y} = position;\n            ctx.beginPath();\n            ctx.arc(x, y, POINT_RADIUS, 0, 2 * Math.PI);\n            ctx.fillStyle = POINT_COLOR;\n            ctx.fill();\n        })\n    }\n\n    clearPoints() {\n        this.pointPositions = null;\n    }\n    // captureStream을 Manual하게 제어하는 함수.\n    // mixedStream의 captureStream(0) 으로 세팅해놔야 requestFrame()이 동작함.\n    captureFrame(time) {\n        if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early\n            window.requestAnimationFrame(this.captureFrame.bind(this));\n            return; // return as there is nothing to do\n        }\n        lastFrameTime = time; // remember the time of the rendered frame\n        // OffscreenCanvas가 있으면 frontCanvas로 전체 이미지를 copy하는 과정이 필요\n        // 현재 Chrome에만 OffscreenCanvas가 지원되기 떄문에 검증작업 필요(2019-11-20 기만)\n        if(typeof(OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.canvas, 0, 0);\n        this.mixedStream.getVideoTracks()[0].requestFrame();\n        window.requestAnimationFrame(this.captureFrame.bind(this))\n    }\n\n    // drawWithWorker(vObjList) {\n    //     vObjList.map(vObj => {\n    //         // console.log(vObj)\n    //         const sT = performance.now();\n    //         const imageData = vObj.getImageData();\n    //         const eT = performance.now();\n    //         // console.log(eT - sT)\n    //         if (!imageData) return;\n    //         this._mainWorker.postMessage({\n    //             type: WORKER_MESSAGE_TYPE.DRAW_IMAGE,\n    //             imageData: imageData,\n    //             left: vObj.left,\n    //             top: vObj.top,\n    //             width: vObj.width,\n    //             height: vObj.height,\n    //             fillMode: vObj.fillMode,\n    //             transparent: vObj.transparent,\n    //         })\n    //     })\n\n    //     this._mainWorker.postMessage({ type: WORKER_MESSAGE_TYPE.DRAW_MAIN_CANVAS })\n    //     // console.log(eT-sT)\n    //     this._drawTimeoutHandler = setTimeout(this.draw.bind(this), _intervalDraw, vObjList)\n    // }\n\n    // addAudioTrack(track) {\n    //     this.mixedStream.addTrack(track)\n    // }\n\n    getVideoTracks() {\n        return this.mixedStream.getVideoTracks();\n    }\n\n    // getMixedStream() { \n    //     return this.mixedStream;\n    // }\n\n    // getTracks() {\n    //     return this.mixedStream.getTracks();\n    // }\n\n    sortVideoObjectList() {\n        this.videoObjectList.sort(function (a, b) {\n            if (a.zIndex < b.zIndex) {\n                return -1;\n            } else if (a.zIndex > b.zIndex) {\n                return 1;\n            } else {\n                if(a.createdAt < b.createdAt) {\n                    return -1;\n                } else if(a.createdAt > b.createdAt) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        })\n        this.videoObjectListAsc = [];\n        for (let i = this.videoObjectList.length - 1; i >= 0; i--) {\n            this.videoObjectListAsc.push(this.videoObjectList[i])\n        }\n        // console.log(this.videoObjectList)\n        // console.log(this.videoObjectListAsc)\n    }\n\n    // getThumbnail(mime = 'image/png', quality=100) {\n    //     return new Promise((resolve, reject) => {\n    //         if(this.canvas === null) {\n    //             return reject(new Error('canvas not exists'));\n    //         }\n    //         this.canvas.toBlob(blob => resolve(blob), mime, quality);\n    //     });\n    // }\n\n    // capture(mime, quality) {\n    //     return this.getThumbnail(mime, quality);\n    // }\n\n    bindEventHandler() {\n        this.uiCanvas.ondblclick = (e) => {\n            const {clickObj, clickPosition} = this.findClickObject(e);\n            if (!clickObj) return;\n            if (clickPosition !== \"move\") return;\n            if (clickObj.isFullscreen()) {\n                // 되돌아갈 position값이 없을경우(처음부터 전체화면으로 삽입)\n                // 그럴경우 좌측 상단으로 보여줌\n                if (!clickObj.hasSavedPosition()) {\n                    clickObj.savePosition();\n                    let width = SIZE.MIN_WIDTH;\n                    let height = SIZE.MIN_HEIGHT;\n                    if(clickObj.width > clickObj.height) {\n                        const ratio = clickObj.height / clickObj.width;\n                        width = SIZE.MIN_WIDTH;\n                        height = width * ratio\n                    } else {\n                        const ratio = clickObj.width / clickObj.height;\n                        height = SIZE.MIN_HEIGHT;\n                        width = height * ratio;\n                    }\n                    clickObj.setPosition({\n                        top: 10,\n                        left: 10,\n                        width,\n                        height,\n                        zIndex: clickObj.zIndex,\n                        fullScreen: false\n                    });\n                } else {\n                    clickObj.restorePosition()\n                }\n                this.mouseOverObject = clickObj;\n            } else {\n                clickObj.savePosition();\n                let aspectRatio = clickObj.width / clickObj.height;\n                if(aspectRatio > 0) { // width > height\n                    const calcWidth = SCREEN.width;\n                    const calcHeight = SCREEN.width / aspectRatio;\n                    if(calcHeight > SCREEN.height) {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: SCREEN.height * aspectRatio,\n                            height: SCREEN.height,\n                            fullScreen: true\n                        });    \n                    } else {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: calcWidth,\n                            height: calcHeight,\n                            fullScreen: true\n                        });    \n                    }\n                } else {\n                    const calcHeight = SCREEN.height;\n                    const calcWidth = SCREEN.height * aspectRatio;\n                    clickObj.setPosition({\n                        top: 0,\n                        left: 0,\n                        width: calcWidth,\n                        height: calcHeight,\n                        fullScreen: true\n                    });\n                }\n\n                this.mouseOverObject = null;\n            }\n            this.sortVideoObjectList();\n        }\n\n        this.uiCanvas.onmousedown = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseButtonState = e.button;\n            if(clickObj) {\n                if(clickObj.isFullscreen()) return;\n\n                this.clickObject = clickObj;\n                this.clickPosition = clickPosition;\n                this.startPos = {\n                    x: e.offsetX,\n                    y: e.offsetY\n                }\n                this.startObjectPos = {\n                    top: clickObj.top,\n                    left: clickObj.left,\n                    bottom: SCREEN.height - (clickObj.top + clickObj.height),\n                    right: SCREEN.width - (clickObj.left + clickObj.width),\n                    width: clickObj.width,\n                    height: clickObj.height,\n                    ratio: clickObj.height / clickObj.width\n                }\n            } else {\n                this.detachEventObject();\n            }\n        }\n        this.uiCanvas.onmouseover = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseOverObject = clickObj;\n            this.clickPosition = clickPosition;\n        }\n        this.uiCanvas.onmouseout = (e) => {\n            this.detachEventObject();\n        }\n        this.uiCanvas.onmousemove = (e) => {\n            switch(this.mouseButtonState) {\n                case MOUSE_BUTTON.NONE:\n                    if(this.mouseOverObject) {\n                        this.detectMouseOut(e)\n                    }\n                    const { clickObj, clickPosition } = this.findClickObject(e);\n                    // fullscreen 모드가 아닌 오브젝트를 계속 scan\n                    if (clickObj) {\n                        this.mouseOverObject = clickObj;\n                        this.clickPosition = clickPosition;\n                        // 마우스 위치에 따라 커서 변경\n                        switch (clickPosition) {\n                            case \"up-arrow\":\n                            case \"down-arrow\":\n                                this.uiCanvas.style.cursor = \"pointer\";\n                                break;\n                            case \"move\":\n                                if(!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"move\";\n                                break;\n                            case \"top-left\":\n                            case \"bottom-right\":\n                                if (!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"nwse-resize\"; // top-left to bottom-right scale cursor\n                                break;\n                        }\n                    }\n                    break;\n                case MOUSE_BUTTON.CLICKED:\n                    if (this.clickObject) {\n                        // 커서 이동한 거리\n                        const moveX = e.offsetX - this.startPos.x;\n                        const moveY = e.offsetY - this.startPos.y;\n                        let moveX_inCanvas = this.calcUItoCanvasX(moveX);\n                        let moveY_inCanvas = this.calcUItoCanvasY(moveY)\n                        let resizeWidth = this.startObjectPos.width;\n                        let resizeHeight = resizeWidth * this.startObjectPos.ratio;\n                        switch (this.clickPosition) {\n                        case \"top-left\":\n                            moveX_inCanvas = -1 * moveX_inCanvas;\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n\n                            // scale\n                            this.clickObject.setPosition({\n                                bottom: this.startObjectPos.bottom,\n                                right: this.startObjectPos.right,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"bottom-right\":\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n                            \n                            // scale\n                            this.clickObject.setPosition({\n                                top: this.startObjectPos.top,\n                                left: this.startObjectPos.left,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"move\":\n                            if(this.clickObject.isFullscreen()) return;\n                            // console.log(e.offsetX )\n                            // console.log(this.startObjectPos.top, this.startObjectPos.left)\n                            // console.log(offsetX, offsetY)\n                            this.clickObject.left = this.startObjectPos.left + moveX_inCanvas;\n                            this.clickObject.top = this.startObjectPos.top + moveY_inCanvas\n                            break;\n                    }\n                }\n            }\n\n            // console.log(e.clientX, e.clientY, e.which);\n        }\n\n        this.uiCanvas.onmouseup = (e) => {\n            this.mouseButtonState = MOUSE_BUTTON.NONE\n        }\n\n        this.uiCanvas.onclick = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            if(clickPosition === \"up-arrow\") {\n                if(clickObj.zIndex < SETTINGS.Z_INDEX_MAX) {\n                    clickObj.zIndex = clickObj.zIndex + 1;\n                    this.sortVideoObjectList();\n                }\n            } else if(clickPosition === \"down-arrow\") {\n                if(clickObj.zIndex > SETTINGS.Z_INDEX_MIN) {\n                    clickObj.zIndex = clickObj.zIndex - 1;\n                    this.sortVideoObjectList();\n                }\n            }\n        }\n    }\n\n    calcUItoCanvasX(x) {\n        return parseInt(x * this.vRatio);\n    }\n\n    calcUItoCanvasY(y) {\n        return parseInt(y * this.hRatio);\n    }\n\n\n    // 마우스포인터가 가르치는 오브젝트 검색\n    findClickObject(e) {\n        // draw는 zIndex가 낮은순으로 하지만,\n        // object detection은 zIndex가 높은순부터 해야 제일 위의 레이어가 선택됨\n        let objList = this.videoObjectListAsc;\n        const mouseX = this.calcUItoCanvasX(e.offsetX);\n        const mouseY = this.calcUItoCanvasY(e.offsetY);\n\n        let clickPosition = \"move\";\n        const findObj = objList.find( vObj => {\n            let objTop = vObj.top;\n            let objLeft = vObj.left;\n            let objBottom = vObj.top + vObj.height;\n            let objRight = vObj.left + vObj.width;\n            if(vObj.isFullscreen()) {\n                objTop = 0;\n                objLeft = 0;\n                objBottom = SCREEN.height;\n                objRight = SCREEN.width;\n            }\n\n\n            // 상단 클릭(높이 조절)\n            // if (mouseY >= (objTop - 2) && mouseY <= (objTop + 2) &&\n            //     mouseX >= (objLeft + 2) && mouseX <= (objRight - 2)) {\n            //     state = \"top\";\n            //     return vObj\n            // }\n\n            // top - left\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.POINT_SIZE) &&\n                mouseX >= objLeft && mouseX <= (objLeft + GUIDE.POINT_SIZE)) {\n                clickPosition = \"top-left\";\n                return vObj;\n            }\n\n            // bottom - right\n            if (mouseY >= (objBottom - GUIDE.POINT_SIZE) && mouseY <= objBottom &&\n                mouseX >= (objRight - GUIDE.POINT_SIZE) && mouseX <= objRight) {\n                clickPosition = \"bottom-right\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex up\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"up-arrow\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex down\n            if (mouseY >= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT * 2) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"down-arrow\";\n                return vObj;\n            }\n\n            // 중앙 클릭()\n            if (mouseY >= objTop && mouseY <= objBottom &&\n                mouseX >= objLeft && mouseX <= objRight) {\n                clickPosition = \"move\";\n                return vObj;\n            }\n        })\n        return { clickObj: findObj, clickPosition }\n    }\n\n    detachEventObject() {\n        this.uiCanvas.style.cursor = null;\n        this.mouseOverObject = null;\n        this.clickObject = null;\n        this.clickPosition = null;\n        this.startPos = null;\n        this.startObjectPos = null;\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n    }\n\n    detectMouseOut(e) {\n        if(!this.mouseOverObject) return;\n        const mouseX = parseInt(e.offsetX * this.vRatio);\n        const mouseY = parseInt(e.offsetY * this.hRatio);\n        // 마우스 좌표와 범위체크\n        // console.log(mouseX, mouseY,\n        //     this.clickObject.left, this.clickObject.right, (this.clickObject.left + this.clickObject.width),\n        //     this.clickObject.top, this.clickObject.bottom, (this.clickObject.top + this.clickObject.height)\n        // )\n        if (mouseX < this.mouseOverObject.left ||\n            mouseX > this.mouseOverObject.right ||\n            mouseX > this.mouseOverObject.left + this.mouseOverObject.width ||\n            mouseY < this.mouseOverObject.top ||\n            mouseY > this.mouseOverObject.bottom ||\n            mouseY > this.mouseOverObject.top + this.mouseOverObject.height) {\n            this.uiCanvas.style.cursor = null;\n            this.mouseOverObject = null;\n        }\n    }\n\n    showObjectDrawTimes() {\n        return this.videoObjectList.map( videoObj => videoObj.lastDrawExecuteTime.toString() )\n    }\n\n}\n","export let SCREEN = {\n    width: 1280,\n    height: 720,\n    // width: 640,\n    // height: 360,\n    // width: 320,\n    // height: 180\n}\n\nconst MARGIN = {\n    TOP: 10,\n    LEFT: 10,\n    RIGHT: 10,\n    BOTTOM: 10\n}\n\nexport const SIZE = {\n    SMALL: {\n        WIDTH: SCREEN.width / 4,\n        HEIGHT: SCREEN.height / 4\n    }\n}\n\nexport const PRESET_POSITION = {\n    FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width,\n        height: SCREEN.height\n    },\n    LEFT_FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    RIGHT_FULL: {\n        top: 0,\n        left: SCREEN.width / 2,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    TOP_LEFT_SMALL: {\n        top: MARGIN.TOP,\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    TOP_RIGHT_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    TOP_CENTER_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalCenter(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_LEFT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    BOTTOM_RIGHT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_CENTER_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalCenter(SIZE.SMALL.HEIGHT),\n        ...SIZE.SMALL\n    }\n}\n\nfunction getHorizontalRight(objWidth) {\n    return SCREEN.width - objWidth - MARGIN.RIGHT;\n}\n\nfunction getHorizontalCenter(objWidth) {\n    return (SCREEN.width / 2) - (objWidth / 2);\n}\n\nfunction getVerticalBottom(objHeight) {\n    return SCREEN.height - objHeight - MARGIN.BOTTOM;\n}\n\nfunction getVerticalCenter(objHeight) {\n    return (SCREEN.height / 2) - (objHeight / 2);\n}","// - 2020-02-13 기만\n// videoObject 내부의 offscreenCanvas에 video source를 지속적으로 draw를 하고,\n// videoMixer 에서 각 videoObject의 이미지(프레임)를 \n// 비동기적으로 draw를 하던방식에서,\n// videoObject는 더이상 draw 하지 않기로 변경\n// 이는 퍼포먼스 측면에서 차이가 없기떄문에 drawCall을 줄이려는 의도임. \n// 참고)\n// https://eggchicken.github.io/web-samples/draw_test.html\n// https://eggchicken.github.io/web-samples/draw_test2.html\n\n\nimport { SCREEN } from './preset/POSITIONS';\n\nexport const EVENT_MSG = {\n    REMOVE_ME: \"REMOVE_ME\"\n}\n\nexport default class VideoObject {\n    constructor(props) {\n        const {\n            id,\n            top, left, bottom, right,\n            width = 0, height = 0,\n            zIndex = 0,\n            fullScreen = false,\n\n            autoSize = false,\n            transparent = false,\n            onended = null,\n\n            visible = true,\n\n            source,\n            sourceType = \"stream\",\n        } = props;\n\n        this._id = id;\n\n        this._transparent = transparent;\n        this._visible = visible;\n\n        this._source = source;\n        this._sourceType = sourceType;\n\n        this._top = top;\n        this._left = left;\n        this._bottom = bottom;\n        this._right = right;\n        this._width = width;\n        this._height = height;\n        this._zIndex = zIndex;\n        this._fullScreen = fullScreen;\n        this._createdAt = performance.now();\n\n        if (autoSize) {\n            const wScale = width / this._source.videoWidth;\n            // const ratio = this._source.videoWidth / this._source.videoHeight;\n            // console.log(this._source.videoHeight, wScale, this._source.videoHeight * wScale)\n            this._height = this._source.videoHeight * wScale;\n        }\n\n        \n        // if (typeof OffscreenCanvas !== \"undefined\") {\n        //     this._offscreenCanvas = new OffscreenCanvas(this._width, this._height);\n        // } else {\n        //     this._offscreenCanvas = document.createElement('canvas');\n        // }\n\n        // this._offscreenCanvasCtx = this._offscreenCanvas.getContext(\n        //     \"2d\",\n        //     {\n        //         desynchronized: true,\n        //         alpha: false\n        //     });\n\n        this.setPosition({\n            top: this._top,\n            left: this._left,\n            bottom: this._bottom,\n            right: this._right,\n            width: this._width,\n            height: this._height\n        })\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    setVisible(value) {\n        this._visible = value;\n    }\n\n    getVisible() {\n        return this._visible;\n    }\n\n    \n    getDrawSource() {\n        if(!this._visible) return;\n        // if(this._outline) this.drawOutline()\n\n        const videoWidth = Math.max(this._source.videoWidth || 0 , this._source.width || 0);\n        const videoHeight = Math.max(this._source.videoHeight || 0, this._source.height || 0)\n        if (videoWidth !== 0 && videoHeight !== 0) {\n            // return { src: this._offscreenCanvas, srcWidth, srcHeight }\n            return { src: this._source, videoWidth, videoHeight }\n        }\n    }\n\n    isFullscreen() {\n        return this._fullScreen;\n    }\n\n    hasSavedPosition() {\n        return this._savedPosition\n    }\n\n    savePosition() {\n        this._oldTop = this._top;\n        this._oldLeft = this._left;\n        this._oldBottom = this._bottom;\n        this._oldRight = this._right;\n        this._oldWidth = this._width;\n        this._oldHeight = this._height;\n        this._oldZIndex = this._zIndex;\n        this._oldFullScreen = this._fullScreen;\n        this._savedPosition = true;\n    }\n\n    restorePosition() {\n        this.setPosition({\n            top: this._oldTop,\n            left: this._oldLeft,\n            bottom: this._oldBottom,\n            right: this.oldRight,\n            width: this._oldWidth,\n            height: this._oldHeight,\n            zIndex: this._oldZIndex,\n            fullScreen: this._oldFullScreen\n        });\n    }\n\n    setPosition(values) {\n        const {\n            top,\n            left,\n            bottom,\n            right,\n            width = this._width,\n            height = this._height,\n            zIndex = this.zIndex,\n            fullScreen = this._fullScreen\n        } = values;\n        this._top = bottom ? undefined : top;\n        this._left = right ? undefined : left;\n        this._bottom = top ? undefined : bottom;\n        this._right = left ? undefined : right;\n        this._width = width ? width : this._width;\n        this._height = height ? height : this._height;\n        this._zIndex = zIndex ? zIndex : this._zIndex;\n        this._fullScreen = fullScreen ? fullScreen : this._fullScreen;\n\n        if (bottom && !top) {\n            this._top = SCREEN.height - bottom - height;\n            this._bottom = undefined;\n        }\n\n        if (right && !left) {\n            this._left = SCREEN.width - right - width;\n            this._right = undefined;\n        }\n        // console.log(\n        //     top,\n        //     left,\n        //     bottom,\n        //     right,\n        //     width,\n        //     height,\n        // )\n        // console.log(\n        //     this._top,\n        //     this._left,\n        //     this._bottom,\n        //     this._right ,\n        //     this._width ,\n        //     this._height ,\n        //     this._zIndex,\n        // )\n\n    }\n\n\n    // autoSize() {\n    //     this._width = this._source.videoWidth;\n    //     this._height = this._source.videoHeight;\n    //     this._offscreenCanvas.width = this._source.videoWidth;\n    //     this._offscreenCanvas.height = this._source.videoHeight;\n    //     setTimeout(this.autoSize.bind(this), 100)\n    // }\n\n\n    get top() {\n        return this._top;\n    }\n\n    set top(top) {\n        this._top = top;\n    }\n\n    get left() {\n        return this._left;\n    }\n\n    set left(left) {\n        this._left = left;\n    }\n\n\n    get width() {\n        return this._width;\n    }\n\n    set width(width) {\n        this._width = width;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    set height(height) {\n        this._height = height;\n    }\n\n    get zIndex() {\n        return this._zIndex;\n    }\n\n    set zIndex(zIndex) {\n        this._zIndex = zIndex;\n    }\n\n    set outLine(onOff) {\n        this._outline = onOff;\n    }\n\n    get createdAt() {\n        return this._createdAt\n    }\n\n    get lastDrawExecuteTime() {\n        return this._drawExecuteTime;\n    }\n}\n\n/** @description src의 형태를 파악하여 스트림으로 변환합니다.\n * @history getStream => convertVideoStream\n * @param {MediaStream|MediaStreamTrack} src MediaStream or MediaStreamTrack\n * @return {MediaStream} stream\n */\nexport const convertVideoStream = src => {\n    const stream = new MediaStream();\n// console.log(src instanceof MediaStream);\n// console.log(src instanceof MediaStreamTrack)\n    if (src instanceof MediaStream) {\n        src.getVideoTracks().forEach(track => stream.addTrack(track));\n    } else if (src instanceof MediaStreamTrack && src.kind === 'video') {\n        stream.addTrack(src);\n    } else {\n        throw new Error();\n    }\n\n    return stream;\n};\n","import Debugger from './StreamMixer.Debugger';\n\nimport AudioMixer from './AudioMixer/AudioMixer';\nimport AudioObject from './AudioMixer/AudioObject';\nimport VideoMixer from './VideoMixer/VideoMixer';\nimport VideoObject from './VideoMixer/VideoObject';\n\nimport { SCREEN, PRESET_POSITION } from './VideoMixer/preset/POSITIONS'\n// import ModuleToWorkerUrl from './Utils/ModuleToWorkerUrl';\n// import { WORKER_MESSAGE_TYPE } from './VideoMixer/VideoObjectWorker';\n\nexport default (() => {\n    let _videoElementList = [];\n    let _videoMixer = null;\n    let _audioMixer = null;\n    let _outputStream = null;\n    let _initSuccess = false;\n\n    const generateID = () => {\n        return '_' + Math.random().toString(36).substr(2, 9);\n    }\n\n    const init = async (props) => {\n        _videoMixer = new VideoMixer(props);\n        // _videoMixer.draw(performance.now());\n        // _videoMixer.drawWithoutFps(performance.now());\n        // _videoMixer.drawWithFps();\n        _videoMixer.drawCalcDeltaTime();\n        // _videoMixer.captureFrame();\n        _audioMixer = new AudioMixer();\n\n        await initOutputStream();\n\n        Debugger.init(_videoElementList, _videoMixer);\n        _initSuccess = true;\n    }\n\n    const initSuccess = () => {\n        return _initSuccess;\n    }\n\n\n    const initOutputStream = async function() {\n        const mixedStream = new MediaStream();\n\n        _videoMixer.getVideoTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _audioMixer.getAudioTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _outputStream = mixedStream;\n    }\n\n    const getStream = () => _outputStream;\n    \n\n    /** @description 미디어를 추가합니다. (Promise)\n     * @param {object} props {source, sourceType, video:{}, audio{}}\n     * source: 미디어 소스 (stream | url)\n     * string sourceType: 미디어 소스에 따라 타입 지정 (\"stream\" | \"url\")\n     * object video: 비디오 위치 및 크기 옵션\n     * object audio: 오디오 옵션\n     * @return {string} objID\n     */\n    const addMedia = (\n        props = {\n            source,\n            sourceType: \"stream\",\n            video: {},\n            audio: {},\n            onended\n        }\n    ) => {\n        return new Promise( async (resolve, reject) => {\n            const { source, sourceType } = props;\n\n            const objID = generateID();\n\n            // 공통 비디오 객체 생성후\n            const videoEl = document.createElement('video');\n            if (sourceType === \"url\") {\n                videoEl.muted = false;\n                videoEl.autoplay = true;\n                videoEl.src = source;\n                videoEl.load();\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n                // videoEl.play();\n                // videoEl.muted = true;\n                videoEl.crossOrigin = 'anonymous';\n            } else {\n                if(props.audio.mediaType === \"mycam\")\n                    videoEl.muted = true;\n                    \n                videoEl.srcObject = source;\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n            }\n\n            // play 직후 cors오류가 떨어질 수 있기 때문에 promise 타입으로 체크\n            videoEl.play()\n            .then(() => {\n                if (sourceType === \"url\") videoEl.crossOrigin = 'anonymous';\n\n                if (props.onended) {\n                    videoEl.onended = () => {\n                        props.onended(objID);\n                    }\n                }\n\n                _videoElementList.push({\n                    id: objID,\n                    videoEl,\n                    stream: sourceType === 'stream' ? source : null\n                })\n\n                const vObj = new VideoObject({\n                    id: objID,\n                    stream: source,\n                    source: videoEl,\n                    sourceType,\n                    ...props.video\n                });\n                _videoMixer.addVideoObject(vObj);\n\n                if(sourceType === \"url\") {\n                    const aObj = new AudioObject({\n                        id: objID,\n                        source: videoEl,\n                        sourceType,\n                        context: _audioMixer.getContext(),\n                        destination: _audioMixer.getDestination(),\n                        ...props.audio,\n                    })\n                    _audioMixer.addAudioObject(aObj);\n                } else {\n                    if(source.getAudioTracks && source.getAudioTracks().length !== 0) {\n                        const aObj = new AudioObject({\n                            id: objID,\n                            source: source,\n                            sourceType,\n                            context: _audioMixer.getContext(),\n                            destination: _audioMixer.getDestination(),\n                            ...props.audio,\n                        })\n                        _audioMixer.addAudioObject(aObj);\n                    }\n                }\n\n                \n                resolve({ objID })\n            })\n            .catch((e) => {\n                console.log(e.toString());\n                reject({ err: \"not play video\" })\n            });\n        })\n    }\n\n    /**\n    * @return {object} {id, videoEl, stream}\n    */\n    const findVideoItem = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        return _videoElementList[idx];\n    }\n\n    const removeMedia = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        // console.log(_videoElementList[idx].id);\n        // console.log(_videoElementList[idx].videoEl)\n        if (idx === -1 || !_videoElementList[idx]) {\n            console.log(`[StreamMixer] %cNot Found MediaObject : ${objID}`,'background: red; color: #fff')\n            return;\n        }\n\n        _videoMixer.removeVideoObject(objID);\n        _audioMixer.removeAudioObject(objID);\n\n        if (_videoElementList[idx].videoEl)\n            _videoElementList[idx].videoEl = undefined;\n        _videoElementList.splice(idx, 1);\n    }\n\n    const getIDs = () => {\n        const ret = _videoElementList.map( k => {\n            return k.id\n        })\n        return ret;\n    }\n\n    const getVideoElement = (objID) => findVideoItem(objID).videoEl;\n\n    const changeStream = (objID, stream) => {\n        return new Promise( (resolve, reject) => {\n            let item = findVideoItem(objID);\n            if(!item) reject(\"not found mediaObject\");\n            \n            item.videoEl.srcObject = stream;\n            item.videoEl.play();\n            return resolve();\n        })\n    }\n\n    const setVisible = function(id, value) {\n        _videoMixer.setVisible(id, value)\n    }\n\n    const pause = function (objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.pause();\n    }\n\n    const play = function(objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.play();\n    }\n\n    const mute = function(id, value) {\n        _audioMixer.mute(id, value)\n    }\n\n    const getCurrentTime = function(id) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if(!item) return 0;\n        return item.videoEl.currentTime;\n    }\n\n    const setCurrentTime = function(id, time) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if (!item) return;\n        item.videoEl.currentTime = time;\n    }\n\n    const setPosition = function(values) {\n        const vObj = _videoMixer.getVideoObject(values.id);\n        if (!vObj) return;\n        vObj.setPosition(values)\n        _videoMixer.sortVideoObjectList();\n    }\n\n    const setVolume = function(id, value) {\n        _audioMixer.setVolume(id, value)\n    }\n\n    const drawPoints = function(positions) {\n        _videoMixer.setPointPositions(positions);\n    }\n\n    const clearPoints = function() {\n        _videoMixer.clearPoints();\n    }\n\n    const setResolution = function(resolution) {\n        _videoMixer.setResolution(resolution)\n    }\n\n    return {\n        init,\n        initSuccess,\n\n        getIDs,\n        getVideoElement,\n\n        addMedia,\n        removeMedia,\n        changeStream,\n        getStream,\n        \n        setResolution,\n\n        pause,\n        play,\n        mute,\n        setVolume,\n        getCurrentTime,\n        setCurrentTime,\n        \n        setVisible,\n        setPosition,\n        drawPoints,\n        clearPoints,\n\n        // getPredictedEncodeTime,\n        // getPredictedEncodeTime,\n        \n        Debug: {...Debugger}\n    }\n    \n})()","import StreamMixer from './StreamMixer';\n// import * as UTILS from './ARTCUtils';\n// import { getVisualiser, getCreator } from './externals';\n\nfunction _prepareNamespaceAndModule(module) {\n    return typeof window.StreamMixer === 'object'\n        ? Object.assign({}, window.StreamMixer, module)\n        : module;\n}\n\nexport default StreamMixer"],"sourceRoot":""}